{"version":3,"file":"Boo60fH3.js","sources":["../../../../node_modules/.pnpm/nuxt@3.19.3_@parcel+watcher@2.5.1_@types+node@22.18.12_@vue+compiler-sfc@3.5.22_db0@0.3.4_esl_c2aodeo2ylv5qpgihuqigxln3e/node_modules/nuxt/dist/app/components/client-only.js"],"sourcesContent":["import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nimport { elToStaticVNode } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nconst STATIC_DIV = \"<div></div>\";\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  ...import.meta.dev && {\n    slots: Object\n  },\n  setup(props, { slots, attrs }) {\n    const mounted = shallowRef(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    const vm = getCurrentInstance();\n    if (vm) {\n      vm._nuxtClientOnly = true;\n    }\n    provide(clientOnlySymbol, true);\n    return () => {\n      if (mounted.value) {\n        const vnodes = slots.default?.();\n        if (vnodes && vnodes.length === 1) {\n          return [cloneVNode(vnodes[0], attrs)];\n        }\n        return vnodes;\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return h(slot);\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      }\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\n    };\n  } else {\n    clone.template &&= `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else>${STATIC_DIV}</template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = shallowRef(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 ||= {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            const res = setupState(...args);\n            const attrs = clone.inheritAttrs !== false ? ctx.attrs : void 0;\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res, attrs) : h(res, attrs);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n"],"names":["clientOnlySymbol","__nuxt_component_1","defineComponent","props","slots","attrs","mounted","shallowRef","onMounted","vm","getCurrentInstance","provide","vnodes","cloneVNode","slot","h","fallbackStr","fallbackTag","createElementBlock"],"mappings":"0EAKY,MAACA,EAAmB,OAAO,IAAI,kBAAkB,EAE7DC,EAAeC,EAAgB,CAC7B,KAAM,aACN,aAAc,GACd,MAAO,CAAC,WAAY,cAAe,iBAAkB,aAAa,EAIlE,MAAMC,EAAO,CAAE,MAAAC,EAAO,MAAAC,CAAK,EAAI,CAC7B,MAAMC,EAAUC,EAAW,EAAK,EAChCC,EAAU,IAAM,CACdF,EAAQ,MAAQ,EAClB,CAAC,EAMD,MAAMG,EAAKC,EAAkB,EAC7B,OAAID,IACFA,EAAG,gBAAkB,IAEvBE,EAAQX,EAAkB,EAAI,EACvB,IAAM,CACX,GAAIM,EAAQ,MAAO,CACjB,MAAMM,EAASR,EAAM,UAAO,EAC5B,OAAIQ,GAAUA,EAAO,SAAW,EACvB,CAACC,EAAWD,EAAO,CAAC,EAAGP,CAAK,CAAC,EAE/BO,CACT,CACA,MAAME,EAAOV,EAAM,UAAYA,EAAM,YACrC,GAAIU,EACF,OAAOC,EAAED,CAAI,EAEf,MAAME,EAAcb,EAAM,UAAYA,EAAM,aAAe,GACrDc,EAAcd,EAAM,aAAeA,EAAM,gBAAkB,OACjE,OAAOe,EAAmBD,EAAaZ,EAAOW,CAAW,CAC3D,CACF,CACF,CAAC","x_google_ignoreList":[0]}